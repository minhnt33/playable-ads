<!doctype html>
<html lang="en">
 <head> 
  <meta charset="utf-8"> 
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"> 
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0, minimal-ui, shrink-to-fit=no"> 
  <meta name="apple-mobile-web-app-capable" content="yes"> 
  <!-- The above 4 meta tags *must* come first in the head; any other head content must come *after* these tags --> 
  <title>playable_ad_example 1.2.0</title> 
  <style type="text/css">
	/* Disable user selection to avoid strange bug in Chrome on Windows:
	* Selecting a text outside the canvas, then clicking+draging would
	* drag the selected text but block mouse down/up events to the engine.
	*/
	body {
	
		position: fixed; /* Prevent overscroll */
	
		margin:0;
		padding:0;
	}

	.canvas-app-container {
		width: 100%;
		height: 100%;
		position: absolute;
		align-items: center;
		justify-content: center;
		overflow: hidden;
	}

	.canvas-app-container:-webkit-full-screen {
		/* Auto width and height in Safari/Chrome fullscreen. */
		width: auto;
		height: auto;
	}

	#canvas {
		outline: none;
		border: 0;
		width: 100%;
		vertical-align: bottom;
	}

	#canvas-container {
		position: relative;
	}

	canvas:focus, canvas:active {
		outline: none;
		border: 0;
		ie-dummy: expression(this.hideFocus=true);
		-moz-outline-style: none;
	}

	div {
		-webkit-tap-highlight-color: rgba(0,0,0,0);
		-webkit-touch-callout: none;
		-webkit-user-select: none;
		-khtml-user-select: none;
		-moz-user-select: none;
		-ms-user-select: none;
		user-select: none;
	}

		.canvas-app-progress {
		position: absolute;
		background-color: #394046;
		height: 6px;
		margin-top: -6px;
		width: 100%;
	}

	.canvas-app-progress-bar {
		font-size: 12px;
		height: 6px;
		color: rgb(255, 255, 255);
		background-color: #1a72eb;
		text-align: center;
		line-height: 20px;
	}
	.link, .button {
		font-family: sans-serif;
		font-size: 14px;
		font-weight: normal;
		font-style: normal;
		font-stretch: normal;
		line-height: normal;
		letter-spacing: 0px;
		padding-top: 12px;
	}

	.buttons-background {
		background-color: #1e2226;
		width: 100%;
		height: 42px;
	}

	body {
		background-color: #1e2226;
	}

	.canvas-app-container {
		background: rgba(36,41,46,1);
		background: -moz-linear-gradient(-45deg, rgba(36,41,46,1) 0%, rgba(36,41,46,1) 49%, rgba(38,43,49,1) 50%, rgba(38,43,49,1) 100%);
		background: -webkit-gradient(left top, right bottom, color-stop(0%, rgba(36,41,46,1)), color-stop(49%, rgba(36,41,46,1)), color-stop(50%, rgba(38,43,49,1)), color-stop(100%, rgba(38,43,49,1)));
		background: -webkit-linear-gradient(-45deg, rgba(36,41,46,1) 0%, rgba(36,41,46,1) 49%, rgba(38,43,49,1) 50%, rgba(38,43,49,1) 100%);
		background: -o-linear-gradient(-45deg, rgba(36,41,46,1) 0%, rgba(36,41,46,1) 49%, rgba(38,43,49,1) 50%, rgba(38,43,49,1) 100%);
		background: -ms-linear-gradient(-45deg, rgba(36,41,46,1) 0%, rgba(36,41,46,1) 49%, rgba(38,43,49,1) 50%, rgba(38,43,49,1) 100%);
		background: linear-gradient(135deg, rgba(36,41,46,1) 0%, rgba(36,41,46,1) 49%, rgba(38,43,49,1) 50%, rgba(38,43,49,1) 100%);
		filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#24292e', endColorstr='#262b31', GradientType=1 );
	}

	.canvas-app-canvas {
		background-repeat:no-repeat;
		background-position: center center;
		background-image: url("splash.png");
	}
	</style> 
  <script data-src="fzstd.js" embed></script>
  <script>
      // Temporary fix to be able to test the game on IE11
      // IE11: Mbed TLS requires /dev/random to run, but https://github.com/emscripten-core/emscripten/pull/7096
      if (window.msCrypto) {
        window.crypto = window.msCrypto;
      }
      // IE11, Chrome ≤45, Edge ≤14, Firefox ≤37: https://github.com/emscripten-core/emscripten/pull/11011/files
      [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array].forEach(
        function (typedArray) {
          if (!typedArray.prototype.slice) {
            Object.defineProperty(typedArray.prototype, "slice", {
              value: function (begin, end) {
                return new typedArray(this.subarray(begin, end));
              },
            });
          }
        }
      );

      // Base64 decoder. RFC 4648, but it doesn't support ending "=" (it is stripped by the gulp script)
      var B64_codes = [
        255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 62,
        255, 255, 255, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 255, 255, 255, 0, 255, 255, 255, 0, 1, 2, 3, 4, 5, 6,
        7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 255, 255, 255, 255, 255, 255, 26, 27,
        28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,
      ];
      function B64_Len(str) {
        return (3 * (str.length / 4)) | 0;
      }
      function B64_U8(str, from, len) {
        if (from && from % 3 != 0) throw "Inv `from`";
        var n = str.length;
        len = len || 3 * (n / 4);
        var result = new Uint8Array(len | 0);
        // console.log("B64_U8", from, "(", from / 3 * 4, ")", len);
        for (var i = from ? (from / 3) * 4 : 0, j = 0; j <= len; i += 4, j += 3) {
          var buffer =
            (B64_codes[str.charCodeAt(i)] << 18) |
            (B64_codes[str.charCodeAt(i + 1)] << 12) |
            (B64_codes[str.charCodeAt(i + 2)] << 6) |
            B64_codes[str.charCodeAt(i + 3)];
          result[j] = buffer >> 16;
          result[j + 1] = (buffer >> 8) & 0xff;
          result[j + 2] = buffer & 0xff;
        }
        return result;
      }

      // Decompresses base64-encoded Zstd data into Uint8Array.
      function Zstd_DecBin(str) {
        return fzstd.decompress(B64_U8(str));
      }

      // Decompresses base64-encoded Zstd data into JS string.
      function Zstd_DecStr(str) {
        // Quick check if we can use fast array to bin string conversion
        //
        // - apply(Array) can fail on Android 2.2
        // - apply(Uint8Array) can fail on iOS 5.1 Safari
        //
        var STR_APPLY_OK = true;
        var STR_APPLY_UIA_OK = true;
        var shrinkBuf = function (buf, size) {
          if (buf.length === size) {
            return buf;
          }
          if (buf.subarray) {
            return buf.subarray(0, size);
          }
          buf.length = size;
          return buf;
        };
        try {
          String.fromCharCode.apply(null, [0]);
        } catch (__) {
          STR_APPLY_OK = false;
        }
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch (__) {
          STR_APPLY_UIA_OK = false;
        }
        var buf2binstring = function (buf, len) {
          // On Chrome, the arguments in a function call that are allowed is `65534`.
          // If the length of the buffer is smaller than that, we can use this optimization,
          // otherwise we will take a slower path.
          if (len < 65534) {
            if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {
              return String.fromCharCode.apply(null, shrinkBuf(buf, len));
            }
          }

          var result = "";
          for (var i = 0; i < len; i++) {
            result += String.fromCharCode(buf[i]);
          }
          return result;
        };
        var buf2string = function (buf, max) {
          var i, out, c, c_len;
          var len = max || buf.length;

          // Reserve max possible length (2 words per char)
          // NB: by unknown reasons, Array is significantly faster for
          //     String.fromCharCode.apply than Uint16Array.
          var utf16buf = new Array(len * 2);

          for (out = 0, i = 0; i < len; ) {
            c = buf[i++];
            // quick process ascii
            if (c < 0x80) {
              utf16buf[out++] = c;
              continue;
            }

            c_len = _utf8len[c];
            // skip 5 & 6 byte codes
            if (c_len > 4) {
              utf16buf[out++] = 0xfffd;
              i += c_len - 1;
              continue;
            }

            // apply mask on first byte
            c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
            // join the rest
            while (c_len > 1 && i < len) {
              c = (c << 6) | (buf[i++] & 0x3f);
              c_len--;
            }

            // terminated by end of string?
            if (c_len > 1) {
              utf16buf[out++] = 0xfffd;
              continue;
            }

            if (c < 0x10000) {
              utf16buf[out++] = c;
            } else {
              c -= 0x10000;
              utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
              utf16buf[out++] = 0xdc00 | (c & 0x3ff);
            }
          }

          return buf2binstring(utf16buf, out);
        };

        return buf2string(Zstd_DecBin(str));
      }

      // Asynchronously converts ArrayBuffer to JS string
      function ArrayBuffer_ToString(buf, callback) {
        var bb = new Blob([new Uint8Array(buf)]);
        var f = new FileReader();
        f.onload = function (e) {
          callback(e.target.result);
        };
        f.readAsText(bb);
      }

      // The Gulp script replaces XMLHttpRequest with ArchiveJsRequest to load files from the compressed data file (.._archive.js), see below.
      var ArchiveJsRequest = function () {
        this.responseType = "text";
      };
      ArchiveJsRequest.prototype.open = function (method, url) {
        this.url = url;
      };
      ArchiveJsRequest.prototype.send = function () {
        var next = function () {
          var time1, time2;
          var logTime = function () {
            var time3 = new Date().getTime();
            console.log(self.url + ": decode " + (time2 - time1) + " ms, onload() " + (time3 - time2) + " ms");
          };

          var self = this;
          if (typeof ARCHIVEJS_DATA === "undefined") {
            console.warn("⚠️⚠️⚠️ playable_ad_example_archive.js is not loaded.");
            self.onerror();
          } else if (!ARCHIVEJS_DATA[self.url]) {
            console.warn("⚠️⚠️⚠️ " + self.url + ": not found");
            self.onerror();
          } else {
            var data = ARCHIVEJS_DATA[self.url];
            self.readyState = 4;
            self.status = 200;

            time1 = new Date().getTime();

            var compressedLen = B64_Len(data[1]);
            var outBuf = new Uint8Array(data[0]);
            var outPos = 0;
            var zstdStream = new fzstd.Decompress(function (chunk, isLast) {
              outBuf.set(chunk, outPos);
              outPos += chunk.byteLength;
              self.onprogress({
                lengthComputable: true,
                total: data[0],
                loaded: outPos,
              });
              if (outPos == data[0]) {
                // Done
                delete ARCHIVEJS_DATA[self.url]; // Free the memory (if it helps, actually)
                if (self.responseType == "text" || self.responseType == "json") {
                  ArrayBuffer_ToString(outBuf, function (text) {
                    self.response = text;
                    time2 = new Date().getTime();
                    self.onload();
                    logTime();
                  });
                } else {
                  self.response = outBuf;
                  time2 = new Date().getTime();
                  self.onload();
                  logTime();
                }
              }
            });

            var chunkLen = 33333;
            var chunkPos = 0;
            var pushChunk = function () {
              chunkLen = Math.min(compressedLen - chunkPos, chunkLen);
              zstdStream.push(B64_U8(data[1], chunkPos, chunkLen));
              chunkPos += chunkLen;
              if (chunkPos == compressedLen) {
                // Last chunk
                zstdStream.push(new Uint8Array(0), true);
              } else {
                setTimeout(pushChunk, 0);
              }
            };
            setTimeout(pushChunk, 0);
          }
        }.bind(this);

        if (typeof ARCHIVEJS_DATA !== "undefined") {
          setTimeout(next, 0);
        } else {
          window.addEventListener("load", next);
        }
      };

      // FB requires to implement the call `FbPlayableAd.onCTAClick` in the JS code. Use it from the Defold like `html5.run("FbPlayableAd_onCTAClick()")`.
      function FbPlayableAd_onCTAClick() {
        try {
          FbPlayableAd.onCTAClick();
        } catch (e) {
          console.error(e);
        }
      }
    </script>
 </head> 
 <body> 
  <div id="app-container" class="canvas-app-container"> 
   <div id="canvas-container" class="canvas-app-canvas-container"> 
    <canvas id="canvas" class="canvas-app-canvas" tabindex="1" width="640" height="1136"></canvas> 
   </div> 
   <div class="buttons-background"> 
   </div> 
  </div> 
  <!-- --> 
  <script id="engine-loader" type="text/javascript" src="dmloader.js" embed="compress"></script> 
  <!-- --> 
  <script id="engine-setup" type="text/javascript">
	var extra_params = {
		archive_location_filter: function( path ) {
			return ("archive" + path + "");
		},
		engine_arguments: ["--verify-graphics-calls=false",],
		custom_heap_size: 67108864,
		full_screen_container: "#canvas-container",
		disable_context_menu: true
	}

	Module['INITIAL_MEMORY'] = extra_params.custom_heap_size;

	Module['onRuntimeInitialized'] = function() {
		Module.runApp("canvas", extra_params);
	};

	Module["locateFile"] = function(path, scriptDirectory)
	{
		// dmengine*.wasm is hardcoded in the built JS loader for WASM,
		// we need to replace it here with the correct project name.
		if (path == "dmengine.wasm" || path == "dmengine_release.wasm" || path == "dmengine_headless.wasm") {
			path = "playable_ad_example.wasm";
		}
		return scriptDirectory + path;
	};

	var is_iOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
	var buttonHeight = 0;
	var prevInnerWidth = -1;
	var prevInnerHeight = -1;
	function resize_game_canvas() {
		// Hack for iOS when exit from Fullscreen mode
		if (is_iOS) {
			window.scrollTo(0, 0);
		}

		var app_container = document.getElementById('app-container');
		var game_canvas = document.getElementById('canvas');
		var innerWidth = window.innerWidth;
		var innerHeight = window.innerHeight - buttonHeight;
		if (prevInnerWidth == innerWidth && prevInnerHeight == innerHeight)
		{
			return;
		}
		prevInnerWidth = innerWidth;
		prevInnerHeight = innerHeight;
		var width = 640;
		var height = 1136;
		var targetRatio = width / height;
		var actualRatio = innerWidth / innerHeight;
	
	
		//Stretch
		width = innerWidth;
		height = innerHeight;
	
	
	
		app_container.style.width = width + "px";
		app_container.style.height = height + buttonHeight + "px";
		game_canvas.width = width;
		game_canvas.height = height;
	}
	resize_game_canvas();
	window.addEventListener('resize', resize_game_canvas, false);
	window.addEventListener('orientationchange', resize_game_canvas, false);
	window.addEventListener('focus', resize_game_canvas, false);
	</script> 
  <script id="engine-start" type="text/javascript">
		EngineLoader.stream_wasm = "false" === "true";
		EngineLoader.load("canvas", "playable_ad_example");
	</script>   
  <script data-src="playable_ad_example_archive.js" embed></script>
 </body>
</html>